<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>libsigrok驱动开发结构解析</title>
      <link href="/2023/03/16/yuque/libsigrok%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/03/16/yuque/libsigrok%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本文主要是介绍如何在 libsigrok 想要增加自己的硬件驱动协议时该如何进行开发的一份指导说明</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>所有的硬件驱动都在 src/hardware 的文件目录底下 在这里可以看到不同厂家实现的不同驱动，尤其是其中的 demo 文件夹下的代码一定要细读 这里是官方提供的示例。<br>所有的驱动都会有一个 api.c 的文件 这个文件就包含了 整个驱动的入口 在这个文件中关于驱动入口比较重点关注的主要是两个 一个是入口结构的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sr_dev_driver</span> <span class="title">demo_driver_info</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">    .longname = <span class="string">&quot;Demo driver and pattern generator&quot;</span>,</span><br><span class="line">    .api_version = <span class="number">1</span>,</span><br><span class="line">    .init = std_init,</span><br><span class="line">    .cleanup = std_cleanup,</span><br><span class="line">    .scan = scan,</span><br><span class="line">    .dev_list = std_dev_list,</span><br><span class="line">    .dev_clear = dev_clear,</span><br><span class="line">    .config_get = config_get,</span><br><span class="line">    .config_set = config_set,</span><br><span class="line">    .config_list = config_list,</span><br><span class="line">    .dev_open = std_dummy_dev_open,</span><br><span class="line">    .dev_close = std_dummy_dev_close,</span><br><span class="line">    .dev_acquisition_start = dev_acquisition_start,</span><br><span class="line">    .dev_acquisition_stop = dev_acquisition_stop,</span><br><span class="line">    .context = <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的结构体中定义了一些名称和版本号以及其他的一些接口函数，另外一个就是 注册结构体的函数<br><code>SR_REGISTER_DEV_DRIVER(demo_driver_info);</code><br>这个方法就是注册了上述结构体的一些参数</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="初始化和销毁"><a href="#初始化和销毁" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h3><p>在硬件的生命周期会涉及到两个一个是初始化另外一个是销毁，其中涉及到的初始化和销毁的函数是以下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Called when driver is loaded, e.g. program startup. */</span></span><br><span class="line"><span class="type">int</span> (*init) (<span class="keyword">struct</span> sr_dev_driver *driver, <span class="keyword">struct</span> sr_context *sr_ctx);</span><br><span class="line"><span class="comment">/** Called before driver is unloaded.</span></span><br><span class="line"><span class="comment"> *  Driver must free all resources held by it. */</span></span><br><span class="line"><span class="type">int</span> (*cleanup) (<span class="type">const</span> <span class="keyword">struct</span> sr_dev_driver *driver);</span><br></pre></td></tr></table></figure><p>其中 init 函数是在驱动加载的时候就会进行的 cleanup 函数是卸载的时候触发</p><h3 id="驱动查询相关"><a href="#驱动查询相关" class="headerlink" title="驱动查询相关"></a>驱动查询相关</h3><p>在硬件初始化后可以通过 scan 函数扫描当前驱动下有哪些可以使用的信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Scan for devices. Driver should do all initialisation required.</span></span><br><span class="line"><span class="comment"> *  Can be called several times, e.g. with different port options.</span></span><br><span class="line"><span class="comment"> *  @retval NULL Error or no devices found.</span></span><br><span class="line"><span class="comment"> *  @retval other GSList of a struct sr_dev_inst for each device.</span></span><br><span class="line"><span class="comment"> *                Must be freed by caller!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">GSList *(*scan) (<span class="keyword">struct</span> sr_dev_driver *driver, GSList *options);</span><br><span class="line"><span class="comment">/** Get list of device instances the driver knows about.</span></span><br><span class="line"><span class="comment"> *  @returns NULL or GSList of a struct sr_dev_inst for each device.</span></span><br><span class="line"><span class="comment"> *           Must not be freed by caller!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">GSList *(*dev_list) (<span class="type">const</span> <span class="keyword">struct</span> sr_dev_driver *driver);</span><br><span class="line"><span class="comment">/** Clear list of devices the driver knows about. */</span></span><br><span class="line"><span class="type">int</span> (*dev_clear) (<span class="type">const</span> <span class="keyword">struct</span> sr_dev_driver *driver);</span><br></pre></td></tr></table></figure><p>其中 scan 的扫描可以扫描当前的</p><h3 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h3><p>如果需要对驱动进行一些配置相关的能力则可以使用这个能力</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Query value of a configuration key in driver or given device instance.</span></span><br><span class="line"><span class="comment"> *  @see sr_config_get().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*config_get) (<span class="type">uint32_t</span> key, GVariant **data,</span><br><span class="line">        <span class="type">const</span> <span class="keyword">struct</span> sr_dev_inst *sdi,</span><br><span class="line">        <span class="type">const</span> <span class="keyword">struct</span> sr_channel_group *cg);</span><br><span class="line"><span class="comment">/** Set value of a configuration key in driver or a given device instance.</span></span><br><span class="line"><span class="comment"> *  @see sr_config_set(). */</span></span><br><span class="line"><span class="type">int</span> (*config_set) (<span class="type">uint32_t</span> key, GVariant *data,</span><br><span class="line">        <span class="type">const</span> <span class="keyword">struct</span> sr_dev_inst *sdi,</span><br><span class="line">        <span class="type">const</span> <span class="keyword">struct</span> sr_channel_group *cg);</span><br><span class="line"><span class="comment">/** List all possible values for a configuration key in a device instance.</span></span><br><span class="line"><span class="comment"> *  @see sr_config_list().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*config_list) (<span class="type">uint32_t</span> key, GVariant **data,</span><br><span class="line">        <span class="type">const</span> <span class="keyword">struct</span> sr_dev_inst *sdi,</span><br><span class="line">        <span class="type">const</span> <span class="keyword">struct</span> sr_channel_group *cg);</span><br></pre></td></tr></table></figure><h3 id="驱动的打开和关闭"><a href="#驱动的打开和关闭" class="headerlink" title="驱动的打开和关闭"></a>驱动的打开和关闭</h3><p>驱动如果在初始化的时候 需要独占的时候可以使用如下函数进行驱动的打开和关闭</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Open device */</span></span><br><span class="line"><span class="type">int</span> (*dev_open) (<span class="keyword">struct</span> sr_dev_inst *sdi);</span><br><span class="line"><span class="comment">/** Close device */</span></span><br><span class="line"><span class="type">int</span> (*dev_close) (<span class="keyword">struct</span> sr_dev_inst *sdi);</span><br></pre></td></tr></table></figure><h3 id="数据的监听和关闭"><a href="#数据的监听和关闭" class="headerlink" title="数据的监听和关闭"></a>数据的监听和关闭</h3><p>在底层驱动中 并不是直接调用获取数据，而是通过函数的回调来告诉上层的函数有新的数据产生 你需要处理新的数据，所以需要对数据进行监听和关闭</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Begin data acquisition on the specified device. */</span></span><br><span class="line"><span class="type">int</span> (*dev_acquisition_start) (<span class="type">const</span> <span class="keyword">struct</span> sr_dev_inst *sdi);</span><br><span class="line"><span class="comment">/** End data acquisition on the specified device. */</span></span><br><span class="line"><span class="type">int</span> (*dev_acquisition_stop) (<span class="keyword">struct</span> sr_dev_inst *sdi);</span><br></pre></td></tr></table></figure><p>其中在 dev_acquisition_start 中有一个比较需要关注的方法是下面的方法这个方法是在 session 中添加回调源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add an event source for a file descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param session The session to use. Must not be NULL.</span></span><br><span class="line"><span class="comment"> * @param fd The file descriptor, or a negative value to create a timer source.</span></span><br><span class="line"><span class="comment"> * @param events Events to check for.</span></span><br><span class="line"><span class="comment"> * @param timeout Max time in ms to wait before the callback is called,</span></span><br><span class="line"><span class="comment"> *                or -1 to wait indefinitely.</span></span><br><span class="line"><span class="comment"> * @param cb Callback function to add. Must not be NULL.</span></span><br><span class="line"><span class="comment"> * @param cb_data Data for the callback function. Can be NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @retval SR_OK Success.</span></span><br><span class="line"><span class="comment"> * @retval SR_ERR_ARG Invalid argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since 0.3.0</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SR_PRIV <span class="type">int</span> <span class="title function_">sr_session_source_add</span><span class="params">(<span class="keyword">struct</span> sr_session *session, <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> events, <span class="type">int</span> timeout, sr_receive_data_callback cb, <span class="type">void</span> *cb_data)</span></span><br></pre></td></tr></table></figure><p>这个方法中比较关注的是在函数中的 cb 函数，这个函数是能够透传数据至上层</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Type definition for callback function for data reception. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*sr_receive_data_callback)</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> revents, <span class="type">void</span> *cb_data)</span>;</span><br></pre></td></tr></table></figure><p>在 demo/protocol.c 的代码中 实现这个函数的方法是 <code>demo_prepare_data</code>这个方法，在这个代码中 我们可以看到如何透传数据 真实的数据产生在<code>logic_generator</code>这个方法来进行产生 我们以<code>SIGROK</code>为例。我们重点代码是如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(devc-&gt;logic_data, <span class="number">0x00</span>, size);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i += devc-&gt;logic_unitsize) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; devc-&gt;logic_unitsize; j++) &#123;</span><br><span class="line">        pat = pattern_sigrok[(devc-&gt;step + j) % <span class="keyword">sizeof</span>(pattern_sigrok)] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        devc-&gt;logic_data[i + j] = ~pat;</span><br><span class="line">    &#125;</span><br><span class="line">    devc-&gt;step++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于透传的数据只需要上传至 <code>devc-&gt;logic_data</code>中就可以了 我们可以看到 demo 中的数据是来源于下面的定义中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> pattern_sigrok[] = &#123;</span><br><span class="line">    <span class="number">0x4c</span>, <span class="number">0x92</span>, <span class="number">0x92</span>, <span class="number">0x92</span>, <span class="number">0x64</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x82</span>, <span class="number">0xfe</span>, <span class="number">0xfe</span>, <span class="number">0x82</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x7c</span>, <span class="number">0x82</span>, <span class="number">0x82</span>, <span class="number">0x92</span>, <span class="number">0x74</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xfe</span>, <span class="number">0x12</span>, <span class="number">0x12</span>, <span class="number">0x32</span>, <span class="number">0xcc</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x7c</span>, <span class="number">0x82</span>, <span class="number">0x82</span>, <span class="number">0x82</span>, <span class="number">0x7c</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xfe</span>, <span class="number">0x10</span>, <span class="number">0x28</span>, <span class="number">0x44</span>, <span class="number">0x82</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0xbe</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一个数据是 0x4c 换算成 2 进制 0100 1100 代码中需要对其进行右移 然后取反则真实传递的数据是 1101 1001<br>第二个数据是 0x92 换算成 2 进行 1001 0010 代码中需要对其进行右移 然后取反则真实传递的数据是 1011 0110<br>对应界面 我们可以看到从 d7-d0 通道 我们可以对应上 以前两个数据为准</p><table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>对应的还需要了解一下 libsigork.h 里面的一些定义</p>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libsigrok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程协定规范</title>
      <link href="/2021/11/16/yuque/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8D%8F%E5%AE%9A%E8%A7%84%E8%8C%83/"/>
      <url>/2021/11/16/yuque/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8D%8F%E5%AE%9A%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了规范开发明确团队相互之间的协作对于目前一些基本定义达成一致标准，尝试制定一些约定。</p><h3 id="代码注释约定-C-、Go、JS"><a href="#代码注释约定-C-、Go、JS" class="headerlink" title="代码注释约定(C++、Go、JS)"></a>代码注释约定(C++、Go、JS)</h3><p>采用统一的标准代码注释约定:</p><h5 id="带参数方法的注释"><a href="#带参数方法的注释" class="headerlink" title="带参数方法的注释"></a>带参数方法的注释</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法注释</span></span><br><span class="line"><span class="comment"> * @param a 参数说明</span></span><br><span class="line"><span class="comment"> * @return 返回值说明</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="无参数方法的注释"><a href="#无参数方法的注释" class="headerlink" title="无参数方法的注释"></a>无参数方法的注释</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法注释</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h5 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变量注释</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><h5 id="方法名约定"><a href="#方法名约定" class="headerlink" title="方法名约定"></a>方法名约定</h5><p>单一约定</p><table><thead><tr><th>名称</th><th>方法名约定</th></tr></thead><tbody><tr><td>新增</td><td>create</td></tr><tr><td>添加</td><td>add</td></tr><tr><td>删除</td><td>remove</td></tr><tr><td>修改</td><td>update</td></tr><tr><td>查询(单个结果)</td><td>get</td></tr><tr><td>查询(多个结果)</td><td>list</td></tr><tr><td>分页查询</td><td>page</td></tr><tr><td>统计</td><td>total</td></tr></tbody></table><p>对仗约定</p><table><thead><tr><th>名称</th><th>方法名约定</th></tr></thead><tbody><tr><td>新增/删除</td><td>add/remove</td></tr><tr><td>初始化/释放</td><td>init/freed</td></tr><tr><td>递增/递减</td><td>increment/decrement</td></tr><tr><td>打开/关闭</td><td>open/close</td></tr><tr><td>开始/结束</td><td>begin/end</td></tr><tr><td>插入/删除(位置)</td><td>insert/delete</td></tr><tr><td>显示/隐藏</td><td>show/hide</td></tr><tr><td>创建/释放</td><td>create/destroy</td></tr><tr><td>锁/解锁</td><td>lock/unlock</td></tr><tr><td>来源/目标(资源)</td><td>source/target</td></tr><tr><td>最前/最后(列表)</td><td>first/last</td></tr><tr><td>最小/最大</td><td>min/max</td></tr><tr><td>获取/设置</td><td>get/set</td></tr><tr><td>往后(下一个)/往前(上一个)</td><td>next/previous</td></tr><tr><td>向上/向下</td><td>up/down</td></tr><tr><td>旧/新</td><td>old/new</td></tr></tbody></table><h3 id="日志规范"><a href="#日志规范" class="headerlink" title="日志规范"></a>日志规范</h3><p>日志规范分别为: ERROR、WARN、INFO、DEBUG</p><h5 id="ERROR-级别"><a href="#ERROR-级别" class="headerlink" title="ERROR 级别"></a>ERROR 级别</h5><p>ERROR 表示不能自动修复的错误信息，需要立即被关注和解决。例如:数据库错误，I/O 错误等。ERROR 的错误信息需要接入报警系统，需要立刻人工介入，及时解决防止线上出问题。</p><h5 id="WARN-级别"><a href="#WARN-级别" class="headerlink" title="WARN 级别"></a>WARN 级别</h5><p>WARN 表示可以自动修复的错误或已知业务问题，为了避免已知的问题进入报警系统采用 WARN 级别的日志。例如:参数校验不通过，没有权限访问业务等。需要注意！！在短时间内产生过多的 WARN 日志，也是一种缺陷，所以最好的方式是设置一个 WARN 的阈值，达到后进行报警。</p><h5 id="INFO-级别"><a href="#INFO-级别" class="headerlink" title="INFO 级别"></a>INFO 级别</h5><p>INFO 表示记录系统的基本运行过程和运行状态，但切忌不能过度使用 INFO，把 INFO 当做 DEBUG 级别的日志使用。</p><h5 id="DEBUG-级别"><a href="#DEBUG-级别" class="headerlink" title="DEBUG 级别"></a>DEBUG 级别</h5><p>DEBUG 表示输出的调试信息，用作在定位问题时需要判断出问题的地方，如:request/response 的对象内容。通常在开发和预发环境下，DEBUG 日志会打开，以方便开发和调试。而线上环境，DEBUG 开关需要被关闭，防止生产环境的日志量过大，避免不必要的服务器的损耗。如果在线上环境遇到问题需要 DEBUG 日志。可以选择动态开启一段时间收集 DEBUG 日志，但是一定要记得关闭！！！</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT 一些小坑</title>
      <link href="/2020/11/16/yuque/QT%20%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91/"/>
      <url>/2020/11/16/yuque/QT%20%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="QT-环境问题"><a href="#QT-环境问题" class="headerlink" title="QT 环境问题"></a>QT 环境问题</h2><h3 id="在第一次使用-QT-时会出现-Kit-无法使用-提示未找到-QT-SDK"><a href="#在第一次使用-QT-时会出现-Kit-无法使用-提示未找到-QT-SDK" class="headerlink" title="在第一次使用 QT 时会出现 Kit 无法使用 提示未找到 QT SDK"></a>在第一次使用 QT 时会出现 Kit 无法使用 提示未找到 QT SDK</h3><p>原因: 在安装后未能正确的编译 qmake 文件，安装时未安装 vc 组件，仅仅安装 mingw<br>解决: 在安装的时候勾选 vc 组件即可编译 qmkae 组件</p><h3 id="使用-Clion-作为开发环境时使用-Cmake-作为编译器时-提示未找到-QT-的环境"><a href="#使用-Clion-作为开发环境时使用-Cmake-作为编译器时-提示未找到-QT-的环境" class="headerlink" title="使用 Clion 作为开发环境时使用 Cmake 作为编译器时 提示未找到 QT 的环境"></a>使用 Clion 作为开发环境时使用 Cmake 作为编译器时 提示未找到 QT 的环境</h3><p>原因: 使用 Cmake 编译时，会提示未能找到 QT 环境<br>解决: 可以在 Cmake 中设置 QT 的环境，但是不建议 最好在系统环境中配置环境变量 这样能让编译后的程序能运行也方便</p><h2 id="QT-其他的小问题"><a href="#QT-其他的小问题" class="headerlink" title="QT 其他的小问题"></a>QT 其他的小问题</h2><h3 id="在-QT-中使用-WindowsApi-函数时，Qmake-编译会报错"><a href="#在-QT-中使用-WindowsApi-函数时，Qmake-编译会报错" class="headerlink" title="在 QT 中使用 WindowsApi 函数时，Qmake 编译会报错"></a>在 QT 中使用 WindowsApi 函数时，Qmake 编译会报错</h3><p>原因: 在编译中未加载 user32.lib 的文件<br>解决: 在 pro 文件中添加 LIBS += -luser32 编译即可解决</p><h3 id="在-QT-中使用网络上的代码时会报错"><a href="#在-QT-中使用网络上的代码时会报错" class="headerlink" title="在 QT 中使用网络上的代码时会报错"></a>在 QT 中使用网络上的代码时会报错</h3><p>原因: QT 中一般使用 GCC 作为主要的编译器其语法主要为 AT&amp;T 格式<br>解决: 针对代码进行翻译写法，需要将原来的 Intel 的格式转换成 AT&amp;T 格式代码</p>]]></content>
      
      
      <categories>
          
          <category> 编程/QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fiddler 抓包手机数据流量</title>
      <link href="/2020/10/14/yuque/Fiddler%20%E6%8A%93%E5%8C%85%E6%89%8B%E6%9C%BA%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8F/"/>
      <url>/2020/10/14/yuque/Fiddler%20%E6%8A%93%E5%8C%85%E6%89%8B%E6%9C%BA%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>手机与电脑处于同一个 Wifi 网络</li><li>获取到电脑的 IP 地址</li></ul><h2 id="安装-Https-的证书"><a href="#安装-Https-的证书" class="headerlink" title="安装 Https 的证书"></a>安装 Https 的证书</h2><ol><li>安卓版本</li></ol><p>在手机浏览器输入电脑的 IP 地址以及 Fiddler 监听的端口,出现如下页面<br><img src="https://cdn.nlark.com/yuque/0/2020/png/240837/1602660421053-873967c6-cf24-4ce2-89e8-c4d470eb470b.png#align=left&display=inline&height=425&name=image.png&originHeight=850&originWidth=2324&size=389786&status=done&style=none&width=1162" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/240837/1602660421053-873967c6-cf24-4ce2-89e8-c4d470eb470b.png#align=left&display=inline&height=425&name=image.png&originHeight=850&originWidth=2324&size=389786&status=done&style=none&width=1162" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"><br>点击如上的证书安装在手机中安装 ssl 的证书</p><ol start="2"><li>IOS 版本</li></ol><p>在手机浏览器输入电脑的 P 地址以及 Fiddler 监听的端口,出现上述页面，同样点击下载证书然后安装在手机中<br>重点手机：<code>设置</code> - <code>通用</code> - <code>关于本机</code> - （最底下）<code>证书信任设置</code>， 点击信任</p><h2 id="Wifi-设定代理"><a href="#Wifi-设定代理" class="headerlink" title="Wifi 设定代理"></a>Wifi 设定代理</h2><p>在手机【设置】中选择【WIFI 设置】选择【处于连接中 WIFI】 一些手机就可以看到代理的设置，另外一些手机需要点击【高级】才能出现<br>在代理中选择【手动】即可配置【主机名】【端口】在【主机名】配置电脑的 IP 地址，在【端口】中配置 Fiddler 监控的端口</p>]]></content>
      
      
      <categories>
          
          <category> 其他/小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac使用工具集合</title>
      <link href="/2020/10/11/yuque/Mac%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"/>
      <url>/2020/10/11/yuque/Mac%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="开发软件类"><a href="#开发软件类" class="headerlink" title="开发软件类"></a>开发软件类</h3><table><thead><tr><th>名称</th><th>作用</th><th>地址</th><th>是否收费</th></tr></thead><tbody><tr><td>JetBrains 全家桶</td><td>开发 IDE</td><td><a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></td><td>收费</td></tr><tr><td>VSCode</td><td>开发 IDE</td><td><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></td><td>免费</td></tr><tr><td>Dash</td><td>离线文档查看工具</td><td><a href="https://www.kapeli.com/dash">https://www.kapeli.com/dash</a></td><td>收费(免费可以使用部分功能)</td></tr><tr><td>Paw</td><td>HTTP 客户端模拟测试</td><td><a href="https://paw.cloud/">https://paw.cloud/</a></td><td>收费</td></tr><tr><td>Termius</td><td>SSH 客户端连接工具</td><td><a href="https://www.termius.com/">https://www.termius.com/</a></td><td>免费</td></tr><tr><td>Draw.io</td><td>画图软件</td><td><a href="https://github.com/jgraph/drawio-desktop/releases">https://github.com/jgraph/drawio-desktop/releases</a></td><td>免费</td></tr><tr><td>Iterm2</td><td>命令行软件</td><td><a href="https://www.iterm2.com/">https://www.iterm2.com/</a></td><td>免费</td></tr><tr><td>Boop</td><td>开发工具辅助软件，可以快速格式化，加解密</td><td>App Store</td><td>免费</td></tr><tr><td>ReactNativeDebugger</td><td>ReactNative 调试工具</td><td><a href="https://github.com/jhen0409/react-native-debugger/releases">https://github.com/jhen0409/react-native-debugger/releases</a></td><td>免费</td></tr></tbody></table><h3 id="工具软件类"><a href="#工具软件类" class="headerlink" title="工具软件类"></a>工具软件类</h3><table><thead><tr><th>名称</th><th>作用</th><th>地址</th><th>是否收费</th></tr></thead><tbody><tr><td>IINA</td><td>视频播放器</td><td><a href="https://www.iina.io/">https://www.iina.io/</a></td><td>免费</td></tr><tr><td>Mos</td><td>鼠标滚轮优化</td><td><a href="https://mos.caldis.me/">https://mos.caldis.me/</a></td><td>免费</td></tr><tr><td>超级右键</td><td>扩展 Mac 右键的功能</td><td><a href="https://www.better365.cn/irightmouse.html">https://www.better365.cn/irightmouse.html</a></td><td>免费</td></tr><tr><td>Rectangle</td><td>Mac 快速分屏软件</td><td><a href="https://github.com/rxhanson/Rectangle/releases">https://github.com/rxhanson/Rectangle/releases</a></td><td>免费</td></tr><tr><td>GoogleTranslate</td><td>谷歌翻译软件</td><td><a href="https://github.com/xaoxuu/GoogleTranslate-Mac/releases">https://github.com/xaoxuu/GoogleTranslate-Mac/releases</a></td><td>免费</td></tr><tr><td>Bandizip</td><td>解压软件</td><td><a href="http://www.bandisoft.com/bandizip.mac/">http://www.bandisoft.com/bandizip.mac/</a></td><td>收费</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 其他/小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建Hexo+GithubPage+GithubAction</title>
      <link href="/2020/03/09/yuque/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAHexo+GithubPage+GithubAction/"/>
      <url>/2020/03/09/yuque/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAHexo+GithubPage+GithubAction/</url>
      
        <content type="html"><![CDATA[<h3 id="1-在-Github-创建两个仓库"><a href="#1-在-Github-创建两个仓库" class="headerlink" title="1. 在 Github 创建两个仓库"></a>1. 在 Github 创建两个仓库</h3><ul><li>Github Page 仓库 仓库的命名方式采用 用户名.github.io 的方式进行命名</li><li>创建一个 Blog 名字的仓库（可随意命名成其他名字）</li></ul><h3 id="2-在-Blog-仓库初始化-Hexo-项目"><a href="#2-在-Blog-仓库初始化-Hexo-项目" class="headerlink" title="2. 在 Blog 仓库初始化 Hexo 项目"></a>2. 在 Blog 仓库初始化 Hexo 项目</h3><ul><li>使用 Hexo 的指令创建 Hexo 的基础项目</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化项目</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地运行hexo项目并演示</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><ul><li>在当前的项目中添加语雀同步插件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加语雀同步插件</span></span><br><span class="line">npm i --save-dev yuque-hexo</span><br></pre></td></tr></table></figure><ul><li>修改 package.json 语雀插件所需要的配置参数</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your hexo project&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;yuqueConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;postPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;source/_posts/yuque&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cachePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yuque.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mdNameFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;title&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;adapter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;concurrency&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.yuque.com/api/v2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;login&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yinzhi&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blog&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;onlyPublished&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;onlyPublic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>postPath</td><td>文档同步后生成的路径</td><td>source/_posts/yuque</td></tr><tr><td>cachePath</td><td>文档下载缓存文件</td><td>yuque.json</td></tr><tr><td>mdNameFormat</td><td>文件名命名方式 (title / slug)</td><td>title</td></tr><tr><td>adapter</td><td>文档生成格式 (hexo/markdown)</td><td>hexo</td></tr><tr><td>concurrency</td><td>下载文章并发数</td><td>5</td></tr><tr><td>baseUrl</td><td>语雀 API 地址</td><td>-</td></tr><tr><td>login</td><td>语雀 login (group), 也称为个人路径</td><td>-</td></tr><tr><td>repo</td><td>语雀仓库短名称，也称为语雀知识库路径</td><td>-</td></tr><tr><td>onlyPublished</td><td>只展示已经发布的文章</td><td>false</td></tr><tr><td>onlyPublic</td><td>只展示公开文章</td><td>false</td></tr></tbody></table><ul><li>添加同步指令</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sync&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yuque-hexo sync&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sync:mac&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YUQUE_TOKEN=XXXX yuque-hexo sync&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sync:win&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set YUQUE_TOKEN=XXXX &amp;&amp; yuque-hexo sync&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean:yuque&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yuque-hexo clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run sync &amp;&amp; hexo clean &amp;&amp; hexo g -d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deploy:mac&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run sync:mac &amp;&amp; hexo clean &amp;&amp; hexo g -d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;publish&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &amp;&amp; hexo g -d&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>YUQUE_TOKEN 的申请地址: <a href="https://www.yuque.com/settings/tokens">https://www.yuque.com/settings/tokens</a> 创建之后填写即可</p><ul><li>配置云函数用作触发 Github Action(以腾讯云为例子)</li></ul><p>在腾讯云云函数地址中: <a href="https://console.cloud.tencent.com/scf/list">https://console.cloud.tencent.com/scf/list</a> 创建云函数选择 python 2.7 模版，并将下述代码添加至模版中,Github 访问的 Token，在 <a href="https://github.com/settings/apps">https://github.com/settings/apps</a> 中选择 “Personal Access Tokens” 页面并点击”Generate new token” 生成一个新的 Token</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    r = requests.post(<span class="string">&quot;https://api.github.com/repos/用户名/仓库名/dispatches&quot;</span>, json = &#123;<span class="string">&quot;event_type&quot;</span>: <span class="string">&quot;start sync yuque&quot;</span>&#125;,</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;curl/7.52.1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/vnd.github.everest-preview+json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;token Github访问Token&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> r.status_code == <span class="number">204</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This&#x27;s OK!&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> r.status_code</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>配置云函数的触发器在触发管理中点击”创建触发器” 触发方式选择 “Api 网关触发器”创建成功后会得到一个访问路径点击复制</li><li>配置语雀的 Webhook 通知云函数由云函数触发 Github Actions，在单个文档集合配置中点击”设置”，点击”开发者”，添加 Web Hook 将得到的访问路径填入 URL 中 ，并点亮 “发布文档”、”更新文档”、”删除文档”</li></ul><h3 id="3-创建-GithubAction-自动编译-Blog-项目并自动上传更新-Github-Page-项目仓库"><a href="#3-创建-GithubAction-自动编译-Blog-项目并自动上传更新-Github-Page-项目仓库" class="headerlink" title="3. 创建 GithubAction 自动编译 Blog 项目并自动上传更新 Github Page 项目仓库"></a>3. 创建 GithubAction 自动编译 Blog 项目并自动上传更新 Github Page 项目仓库</h3><ul><li><p>在 Github 中添加 YUQUE_TOKEN</p></li><li><p>在 Blog 的仓库中添加 Github Actions 的编译代码</p></li></ul><p>-</p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3>]]></content>
      
      
      <categories>
          
          <category> 配置/博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu Mysql 安装手册</title>
      <link href="/2019/01/09/yuque/Ubuntu%20Mysql%20%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/"/>
      <url>/2019/01/09/yuque/Ubuntu%20Mysql%20%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="1-更新源"><a href="#1-更新源" class="headerlink" title="1. 更新源"></a>1. 更新源</h3><p>首先将 Ubuntu 的 apt 源更新至最新的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="2-安装-Mysql-服务"><a href="#2-安装-Mysql-服务" class="headerlink" title="2. 安装 Mysql 服务"></a>2. 安装 Mysql 服务</h3><p>通过 apt 源安装 mysql 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure><p>在安装过程中会提示输入 root 密码</p><h3 id="3-配置-Mysql-的-Root-用户访问-ip"><a href="#3-配置-Mysql-的-Root-用户访问-ip" class="headerlink" title="3. 配置 Mysql 的 Root 用户访问 ip"></a>3. 配置 Mysql 的 Root 用户访问 ip</h3><p>默认情况下 root 账户只允许在本机访问需要给 root 账户增加在其他 ip 访问的权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> root@&quot;%&quot; IDENTIFIED <span class="keyword">BY</span> &quot;1q2w3e4r&quot;;</span><br></pre></td></tr></table></figure><h3 id="4-配置-Mysql-的服务绑定-IP"><a href="#4-配置-Mysql-的服务绑定-IP" class="headerlink" title="4. 配置 Mysql 的服务绑定 IP"></a>4. 配置 Mysql 的服务绑定 IP</h3><p>默认 Mysql 的绑定 IP 为 127.0.0.1，如果需要让 Root 用户访问则需要更改绑定的 ip 为当前服务器的外网 ip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/mysql/mysql.conf.d</span><br></pre></td></tr></table></figure><p>将当前目录移动到 mysql.conf.d 文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim mysqld.conf</span><br></pre></td></tr></table></figure><p>编辑 mysqld.conf 文件，找到 bind-address 将值修改为对应的 IP</p>]]></content>
      
      
      <categories>
          
          <category> 配置/运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> mysql </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
