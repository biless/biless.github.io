{"meta":{"title":"Biles'Blog","subtitle":null,"description":"我的中文博客","author":"Biles","url":"https://bileskou.blog","root":"/"},"pages":[{"title":"关于我","date":"2020-03-16T07:16:12.000Z","updated":"2023-03-17T07:53:13.591Z","comments":true,"path":"about/index.html","permalink":"https://bileskou.blog/about/index.html","excerpt":"","text":"我就是我"}],"posts":[{"title":"libsigrok驱动开发结构解析","slug":"yuque/libsigrok驱动开发结构解析","date":"2023-03-16T01:49:08.000Z","updated":"2023-03-17T07:53:39.303Z","comments":true,"path":"2023/03/16/yuque/libsigrok驱动开发结构解析/","link":"","permalink":"https://bileskou.blog/2023/03/16/yuque/libsigrok%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/","excerpt":"","text":"本文主要是介绍如何在 libsigrok 想要增加自己的硬件驱动协议时该如何进行开发的一份指导说明 准备所有的硬件驱动都在 src/hardware 的文件目录底下 在这里可以看到不同厂家实现的不同驱动，尤其是其中的 demo 文件夹下的代码一定要细读 这里是官方提供的示例。所有的驱动都会有一个 api.c 的文件 这个文件就包含了 整个驱动的入口 在这个文件中关于驱动入口比较重点关注的主要是两个 一个是入口结构的定义: 123456789101112131415161718static struct sr_dev_driver demo_driver_info = &#123; .name = &quot;demo&quot;, .longname = &quot;Demo driver and pattern generator&quot;, .api_version = 1, .init = std_init, .cleanup = std_cleanup, .scan = scan, .dev_list = std_dev_list, .dev_clear = dev_clear, .config_get = config_get, .config_set = config_set, .config_list = config_list, .dev_open = std_dummy_dev_open, .dev_close = std_dummy_dev_close, .dev_acquisition_start = dev_acquisition_start, .dev_acquisition_stop = dev_acquisition_stop, .context = NULL,&#125;; 在上面的结构体中定义了一些名称和版本号以及其他的一些接口函数，另外一个就是 注册结构体的函数SR_REGISTER_DEV_DRIVER(demo_driver_info);这个方法就是注册了上述结构体的一些参数 详解初始化和销毁在硬件的生命周期会涉及到两个一个是初始化另外一个是销毁，其中涉及到的初始化和销毁的函数是以下函数 12345/** Called when driver is loaded, e.g. program startup. */int (*init) (struct sr_dev_driver *driver, struct sr_context *sr_ctx);/** Called before driver is unloaded. * Driver must free all resources held by it. */int (*cleanup) (const struct sr_dev_driver *driver); 其中 init 函数是在驱动加载的时候就会进行的 cleanup 函数是卸载的时候触发 驱动查询相关在硬件初始化后可以通过 scan 函数扫描当前驱动下有哪些可以使用的信号 1234567891011121314/** Scan for devices. Driver should do all initialisation required. * Can be called several times, e.g. with different port options. * @retval NULL Error or no devices found. * @retval other GSList of a struct sr_dev_inst for each device. * Must be freed by caller! */GSList *(*scan) (struct sr_dev_driver *driver, GSList *options);/** Get list of device instances the driver knows about. * @returns NULL or GSList of a struct sr_dev_inst for each device. * Must not be freed by caller! */GSList *(*dev_list) (const struct sr_dev_driver *driver);/** Clear list of devices the driver knows about. */int (*dev_clear) (const struct sr_dev_driver *driver); 其中 scan 的扫描可以扫描当前的 配置相关如果需要对驱动进行一些配置相关的能力则可以使用这个能力 1234567891011121314151617/** Query value of a configuration key in driver or given device instance. * @see sr_config_get(). */int (*config_get) (uint32_t key, GVariant **data, const struct sr_dev_inst *sdi, const struct sr_channel_group *cg);/** Set value of a configuration key in driver or a given device instance. * @see sr_config_set(). */int (*config_set) (uint32_t key, GVariant *data, const struct sr_dev_inst *sdi, const struct sr_channel_group *cg);/** List all possible values for a configuration key in a device instance. * @see sr_config_list(). */int (*config_list) (uint32_t key, GVariant **data, const struct sr_dev_inst *sdi, const struct sr_channel_group *cg); 驱动的打开和关闭驱动如果在初始化的时候 需要独占的时候可以使用如下函数进行驱动的打开和关闭 1234/** Open device */int (*dev_open) (struct sr_dev_inst *sdi);/** Close device */int (*dev_close) (struct sr_dev_inst *sdi); 数据的监听和关闭在底层驱动中 并不是直接调用获取数据，而是通过函数的回调来告诉上层的函数有新的数据产生 你需要处理新的数据，所以需要对数据进行监听和关闭 1234/** Begin data acquisition on the specified device. */int (*dev_acquisition_start) (const struct sr_dev_inst *sdi);/** End data acquisition on the specified device. */int (*dev_acquisition_stop) (struct sr_dev_inst *sdi); 其中在 dev_acquisition_start 中有一个比较需要关注的方法是下面的方法这个方法是在 session 中添加回调源 12345678910111213141516171819/** * Add an event source for a file descriptor. * * @param session The session to use. Must not be NULL. * @param fd The file descriptor, or a negative value to create a timer source. * @param events Events to check for. * @param timeout Max time in ms to wait before the callback is called, * or -1 to wait indefinitely. * @param cb Callback function to add. Must not be NULL. * @param cb_data Data for the callback function. Can be NULL. * * @retval SR_OK Success. * @retval SR_ERR_ARG Invalid argument. * * @since 0.3.0 * @private */SR_PRIV int sr_session_source_add(struct sr_session *session, int fd, int events, int timeout, sr_receive_data_callback cb, void *cb_data) 这个方法中比较关注的是在函数中的 cb 函数，这个函数是能够透传数据至上层 12/** Type definition for callback function for data reception. */typedef int (*sr_receive_data_callback)(int fd, int revents, void *cb_data); 在 demo/protocol.c 的代码中 实现这个函数的方法是 demo_prepare_data这个方法，在这个代码中 我们可以看到如何透传数据 真实的数据产生在logic_generator这个方法来进行产生 我们以SIGROK为例。我们重点代码是如下代码 12345678memset(devc-&gt;logic_data, 0x00, size);for (i = 0; i &lt; size; i += devc-&gt;logic_unitsize) &#123; for (j = 0; j &lt; devc-&gt;logic_unitsize; j++) &#123; pat = pattern_sigrok[(devc-&gt;step + j) % sizeof(pattern_sigrok)] &gt;&gt; 1; devc-&gt;logic_data[i + j] = ~pat; &#125; devc-&gt;step++;&#125; 对于透传的数据只需要上传至 devc-&gt;logic_data中就可以了 我们可以看到 demo 中的数据是来源于下面的定义中 12345678910static const uint8_t pattern_sigrok[] = &#123; 0x4c, 0x92, 0x92, 0x92, 0x64, 0x00, 0x00, 0x00, 0x82, 0xfe, 0xfe, 0x82, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x82, 0x82, 0x92, 0x74, 0x00, 0x00, 0x00, 0xfe, 0x12, 0x12, 0x32, 0xcc, 0x00, 0x00, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00, 0xfe, 0x10, 0x28, 0x44, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbe, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#125;; 第一个数据是 0x4c 换算成 2 进制 0100 1100 代码中需要对其进行右移 然后取反则真实传递的数据是 1101 1001第二个数据是 0x92 换算成 2 进行 1001 0010 代码中需要对其进行右移 然后取反则真实传递的数据是 1011 0110对应界面 我们可以看到从 d7-d0 通道 我们可以对应上 以前两个数据为准 D7 D6 D5 D4 D3 D2 D1 D0 1 1 0 1 1 0 0 1 1 0 1 1 0 1 1 0 补充对应的还需要了解一下 libsigork.h 里面的一些定义","categories":[{"name":"硬件","slug":"硬件","permalink":"https://bileskou.blog/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"libsigrok","slug":"libsigrok","permalink":"https://bileskou.blog/tags/libsigrok/"}]},{"title":"软件工程协定规范","slug":"yuque/软件工程协定规范","date":"2021-11-16T03:14:42.000Z","updated":"2023-03-17T07:53:39.303Z","comments":true,"path":"2021/11/16/yuque/软件工程协定规范/","link":"","permalink":"https://bileskou.blog/2021/11/16/yuque/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8D%8F%E5%AE%9A%E8%A7%84%E8%8C%83/","excerpt":"","text":"前言为了规范开发明确团队相互之间的协作对于目前一些基本定义达成一致标准，尝试制定一些约定。 代码注释约定(C++、Go、JS)采用统一的标准代码注释约定: 带参数方法的注释123456/** * 方法注释 * @param a 参数说明 * @return 返回值说明 **/bool func(int a); 无参数方法的注释1234/** * 方法注释 **/void func(); 变量说明1234/** * 变量注释 **/int a; 命名约定方法名约定单一约定 名称 方法名约定 新增 create 添加 add 删除 remove 修改 update 查询(单个结果) get 查询(多个结果) list 分页查询 page 统计 total 对仗约定 名称 方法名约定 新增/删除 add/remove 初始化/释放 init/freed 递增/递减 increment/decrement 打开/关闭 open/close 开始/结束 begin/end 插入/删除(位置) insert/delete 显示/隐藏 show/hide 创建/释放 create/destroy 锁/解锁 lock/unlock 来源/目标(资源) source/target 最前/最后(列表) first/last 最小/最大 min/max 获取/设置 get/set 往后(下一个)/往前(上一个) next/previous 向上/向下 up/down 旧/新 old/new 日志规范日志规范分别为: ERROR、WARN、INFO、DEBUG ERROR 级别ERROR 表示不能自动修复的错误信息，需要立即被关注和解决。例如:数据库错误，I/O 错误等。ERROR 的错误信息需要接入报警系统，需要立刻人工介入，及时解决防止线上出问题。 WARN 级别WARN 表示可以自动修复的错误或已知业务问题，为了避免已知的问题进入报警系统采用 WARN 级别的日志。例如:参数校验不通过，没有权限访问业务等。需要注意！！在短时间内产生过多的 WARN 日志，也是一种缺陷，所以最好的方式是设置一个 WARN 的阈值，达到后进行报警。 INFO 级别INFO 表示记录系统的基本运行过程和运行状态，但切忌不能过度使用 INFO，把 INFO 当做 DEBUG 级别的日志使用。 DEBUG 级别DEBUG 表示输出的调试信息，用作在定位问题时需要判断出问题的地方，如:request/response 的对象内容。通常在开发和预发环境下，DEBUG 日志会打开，以方便开发和调试。而线上环境，DEBUG 开关需要被关闭，防止生产环境的日志量过大，避免不必要的服务器的损耗。如果在线上环境遇到问题需要 DEBUG 日志。可以选择动态开启一段时间收集 DEBUG 日志，但是一定要记得关闭！！！","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://bileskou.blog/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://bileskou.blog/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"QT 一些小坑","slug":"yuque/QT 一些小坑","date":"2020-11-16T07:44:10.000Z","updated":"2023-03-17T07:53:39.303Z","comments":true,"path":"2020/11/16/yuque/QT 一些小坑/","link":"","permalink":"https://bileskou.blog/2020/11/16/yuque/QT%20%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91/","excerpt":"","text":"QT 环境问题在第一次使用 QT 时会出现 Kit 无法使用 提示未找到 QT SDK原因: 在安装后未能正确的编译 qmake 文件，安装时未安装 vc 组件，仅仅安装 mingw解决: 在安装的时候勾选 vc 组件即可编译 qmkae 组件 使用 Clion 作为开发环境时使用 Cmake 作为编译器时 提示未找到 QT 的环境原因: 使用 Cmake 编译时，会提示未能找到 QT 环境解决: 可以在 Cmake 中设置 QT 的环境，但是不建议 最好在系统环境中配置环境变量 这样能让编译后的程序能运行也方便 QT 其他的小问题在 QT 中使用 WindowsApi 函数时，Qmake 编译会报错原因: 在编译中未加载 user32.lib 的文件解决: 在 pro 文件中添加 LIBS += -luser32 编译即可解决 在 QT 中使用网络上的代码时会报错原因: QT 中一般使用 GCC 作为主要的编译器其语法主要为 AT&amp;T 格式解决: 针对代码进行翻译写法，需要将原来的 Intel 的格式转换成 AT&amp;T 格式代码","categories":[{"name":"编程/QT","slug":"编程-QT","permalink":"https://bileskou.blog/categories/%E7%BC%96%E7%A8%8B-QT/"}],"tags":[{"name":"qt","slug":"qt","permalink":"https://bileskou.blog/tags/qt/"},{"name":"cpp","slug":"cpp","permalink":"https://bileskou.blog/tags/cpp/"}]},{"title":"Fiddler 抓包手机数据流量","slug":"yuque/Fiddler 抓包手机数据流量","date":"2020-10-14T07:01:36.000Z","updated":"2023-03-17T07:53:39.303Z","comments":true,"path":"2020/10/14/yuque/Fiddler 抓包手机数据流量/","link":"","permalink":"https://bileskou.blog/2020/10/14/yuque/Fiddler%20%E6%8A%93%E5%8C%85%E6%89%8B%E6%9C%BA%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8F/","excerpt":"","text":"准备工作 手机与电脑处于同一个 Wifi 网络 获取到电脑的 IP 地址 安装 Https 的证书 安卓版本 在手机浏览器输入电脑的 IP 地址以及 Fiddler 监听的端口,出现如下页面点击如上的证书安装在手机中安装 ssl 的证书 IOS 版本 在手机浏览器输入电脑的 P 地址以及 Fiddler 监听的端口,出现上述页面，同样点击下载证书然后安装在手机中重点手机：设置 - 通用 - 关于本机 - （最底下）证书信任设置， 点击信任 Wifi 设定代理在手机【设置】中选择【WIFI 设置】选择【处于连接中 WIFI】 一些手机就可以看到代理的设置，另外一些手机需要点击【高级】才能出现在代理中选择【手动】即可配置【主机名】【端口】在【主机名】配置电脑的 IP 地址，在【端口】中配置 Fiddler 监控的端口","categories":[{"name":"其他/小技巧","slug":"其他-小技巧","permalink":"https://bileskou.blog/categories/%E5%85%B6%E4%BB%96-%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"fiddler","slug":"fiddler","permalink":"https://bileskou.blog/tags/fiddler/"}]},{"title":"Mac使用工具集合","slug":"yuque/Mac使用工具集合","date":"2020-10-10T18:01:38.000Z","updated":"2023-03-17T07:53:39.303Z","comments":true,"path":"2020/10/11/yuque/Mac使用工具集合/","link":"","permalink":"https://bileskou.blog/2020/10/11/yuque/Mac%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/","excerpt":"","text":"开发软件类 名称 作用 地址 是否收费 JetBrains 全家桶 开发 IDE https://www.jetbrains.com/ 收费 VSCode 开发 IDE https://code.visualstudio.com/ 免费 Dash 离线文档查看工具 https://www.kapeli.com/dash 收费(免费可以使用部分功能) Paw HTTP 客户端模拟测试 https://paw.cloud/ 收费 Termius SSH 客户端连接工具 https://www.termius.com/ 免费 Draw.io 画图软件 https://github.com/jgraph/drawio-desktop/releases 免费 Iterm2 命令行软件 https://www.iterm2.com/ 免费 Boop 开发工具辅助软件，可以快速格式化，加解密 App Store 免费 ReactNativeDebugger ReactNative 调试工具 https://github.com/jhen0409/react-native-debugger/releases 免费 工具软件类 名称 作用 地址 是否收费 IINA 视频播放器 https://www.iina.io/ 免费 Mos 鼠标滚轮优化 https://mos.caldis.me/ 免费 超级右键 扩展 Mac 右键的功能 https://www.better365.cn/irightmouse.html 免费 Rectangle Mac 快速分屏软件 https://github.com/rxhanson/Rectangle/releases 免费 GoogleTranslate 谷歌翻译软件 https://github.com/xaoxuu/GoogleTranslate-Mac/releases 免费 Bandizip 解压软件 http://www.bandisoft.com/bandizip.mac/ 收费","categories":[{"name":"其他/小技巧","slug":"其他-小技巧","permalink":"https://bileskou.blog/categories/%E5%85%B6%E4%BB%96-%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://bileskou.blog/tags/mac/"}]},{"title":"博客搭建Hexo+GithubPage+GithubAction","slug":"yuque/博客搭建Hexo+GithubPage+GithubAction","date":"2020-03-09T12:03:42.000Z","updated":"2023-03-17T07:53:39.303Z","comments":true,"path":"2020/03/09/yuque/博客搭建Hexo+GithubPage+GithubAction/","link":"","permalink":"https://bileskou.blog/2020/03/09/yuque/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAHexo+GithubPage+GithubAction/","excerpt":"","text":"1. 在 Github 创建两个仓库 Github Page 仓库 仓库的命名方式采用 用户名.github.io 的方式进行命名 创建一个 Blog 名字的仓库（可随意命名成其他名字） 2. 在 Blog 仓库初始化 Hexo 项目 使用 Hexo 的指令创建 Hexo 的基础项目 1234# 初始化项目hexo init# 本地运行hexo项目并演示hexo s 在当前的项目中添加语雀同步插件 12# 添加语雀同步插件npm i --save-dev yuque-hexo 修改 package.json 语雀插件所需要的配置参数 123456789101112131415&#123; &quot;name&quot;: &quot;your hexo project&quot;, &quot;yuqueConfig&quot;: &#123; &quot;postPath&quot;: &quot;source/_posts/yuque&quot;, &quot;cachePath&quot;: &quot;yuque.json&quot;, &quot;mdNameFormat&quot;: &quot;title&quot;, &quot;adapter&quot;: &quot;hexo&quot;, &quot;concurrency&quot;: 5, &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;, &quot;login&quot;: &quot;yinzhi&quot;, &quot;repo&quot;: &quot;blog&quot;, &quot;onlyPublished&quot;: false, &quot;onlyPublic&quot;: false &#125;&#125; 参数名 含义 默认值 postPath 文档同步后生成的路径 source/_posts/yuque cachePath 文档下载缓存文件 yuque.json mdNameFormat 文件名命名方式 (title / slug) title adapter 文档生成格式 (hexo/markdown) hexo concurrency 下载文章并发数 5 baseUrl 语雀 API 地址 - login 语雀 login (group), 也称为个人路径 - repo 语雀仓库短名称，也称为语雀知识库路径 - onlyPublished 只展示已经发布的文章 false onlyPublic 只展示公开文章 false 添加同步指令 1234567891011&#123; &quot;scripts&quot;: &#123; &quot;sync&quot;: &quot;yuque-hexo sync&quot;, &quot;sync:mac&quot;: &quot;YUQUE_TOKEN=XXXX yuque-hexo sync&quot;, &quot;sync:win&quot;: &quot;set YUQUE_TOKEN=XXXX &amp;&amp; yuque-hexo sync&quot;, &quot;clean:yuque&quot;: &quot;yuque-hexo clean&quot;, &quot;deploy&quot;: &quot;npm run sync &amp;&amp; hexo clean &amp;&amp; hexo g -d&quot;, &quot;deploy:mac&quot;: &quot;npm run sync:mac &amp;&amp; hexo clean &amp;&amp; hexo g -d&quot;, &quot;publish&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot; &#125;&#125; YUQUE_TOKEN 的申请地址: https://www.yuque.com/settings/tokens 创建之后填写即可 配置云函数用作触发 Github Action(以腾讯云为例子) 在腾讯云云函数地址中: https://console.cloud.tencent.com/scf/list 创建云函数选择 python 2.7 模版，并将下述代码添加至模版中,Github 访问的 Token，在 https://github.com/settings/apps 中选择 “Personal Access Tokens” 页面并点击”Generate new token” 生成一个新的 Token 1234567891011121314# -*- coding: utf8 -*-import requestsdef main_handler(event, context): r = requests.post(&quot;https://api.github.com/repos/用户名/仓库名/dispatches&quot;, json = &#123;&quot;event_type&quot;: &quot;start sync yuque&quot;&#125;, headers = &#123; &#x27;User-Agent&#x27;:&#x27;curl/7.52.1&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#x27;Accept&#x27;: &#x27;application/vnd.github.everest-preview+json&#x27;, &#x27;Authorization&#x27;: &#x27;token Github访问Token&#x27;&#125;) if r.status_code == 204: return &quot;This&#x27;s OK!&quot; else: return r.status_code 配置云函数的触发器在触发管理中点击”创建触发器” 触发方式选择 “Api 网关触发器”创建成功后会得到一个访问路径点击复制 配置语雀的 Webhook 通知云函数由云函数触发 Github Actions，在单个文档集合配置中点击”设置”，点击”开发者”，添加 Web Hook 将得到的访问路径填入 URL 中 ，并点亮 “发布文档”、”更新文档”、”删除文档” 3. 创建 GithubAction 自动编译 Blog 项目并自动上传更新 Github Page 项目仓库 在 Github 中添加 YUQUE_TOKEN 在 Blog 的仓库中添加 Github Actions 的编译代码 - 4.","categories":[{"name":"配置/博客","slug":"配置-博客","permalink":"https://bileskou.blog/categories/%E9%85%8D%E7%BD%AE-%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://bileskou.blog/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://bileskou.blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Ubuntu Mysql 安装手册","slug":"yuque/Ubuntu Mysql 安装手册","date":"2019-01-09T06:49:12.000Z","updated":"2023-03-17T07:53:39.303Z","comments":true,"path":"2019/01/09/yuque/Ubuntu Mysql 安装手册/","link":"","permalink":"https://bileskou.blog/2019/01/09/yuque/Ubuntu%20Mysql%20%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/","excerpt":"","text":"1. 更新源首先将 Ubuntu 的 apt 源更新至最新的 1sudo apt update 2. 安装 Mysql 服务通过 apt 源安装 mysql 服务 1sudo apt install mysql-server 在安装过程中会提示输入 root 密码 3. 配置 Mysql 的 Root 用户访问 ip默认情况下 root 账户只允许在本机访问需要给 root 账户增加在其他 ip 访问的权限 1GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &quot;1q2w3e4r&quot;; 4. 配置 Mysql 的服务绑定 IP默认 Mysql 的绑定 IP 为 127.0.0.1，如果需要让 Root 用户访问则需要更改绑定的 ip 为当前服务器的外网 ip 1cd /etc/mysql/mysql.conf.d 将当前目录移动到 mysql.conf.d 文件夹 1vim mysqld.conf 编辑 mysqld.conf 文件，找到 bind-address 将值修改为对应的 IP","categories":[{"name":"配置/运维","slug":"配置-运维","permalink":"https://bileskou.blog/categories/%E9%85%8D%E7%BD%AE-%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://bileskou.blog/tags/ubuntu/"},{"name":"mysql","slug":"mysql","permalink":"https://bileskou.blog/tags/mysql/"},{"name":"运维","slug":"运维","permalink":"https://bileskou.blog/tags/%E8%BF%90%E7%BB%B4/"}]}],"categories":[{"name":"硬件","slug":"硬件","permalink":"https://bileskou.blog/categories/%E7%A1%AC%E4%BB%B6/"},{"name":"软件工程","slug":"软件工程","permalink":"https://bileskou.blog/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"编程/QT","slug":"编程-QT","permalink":"https://bileskou.blog/categories/%E7%BC%96%E7%A8%8B-QT/"},{"name":"其他/小技巧","slug":"其他-小技巧","permalink":"https://bileskou.blog/categories/%E5%85%B6%E4%BB%96-%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"配置/博客","slug":"配置-博客","permalink":"https://bileskou.blog/categories/%E9%85%8D%E7%BD%AE-%E5%8D%9A%E5%AE%A2/"},{"name":"配置/运维","slug":"配置-运维","permalink":"https://bileskou.blog/categories/%E9%85%8D%E7%BD%AE-%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"libsigrok","slug":"libsigrok","permalink":"https://bileskou.blog/tags/libsigrok/"},{"name":"软件工程","slug":"软件工程","permalink":"https://bileskou.blog/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"qt","slug":"qt","permalink":"https://bileskou.blog/tags/qt/"},{"name":"cpp","slug":"cpp","permalink":"https://bileskou.blog/tags/cpp/"},{"name":"fiddler","slug":"fiddler","permalink":"https://bileskou.blog/tags/fiddler/"},{"name":"mac","slug":"mac","permalink":"https://bileskou.blog/tags/mac/"},{"name":"hexo","slug":"hexo","permalink":"https://bileskou.blog/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://bileskou.blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://bileskou.blog/tags/ubuntu/"},{"name":"mysql","slug":"mysql","permalink":"https://bileskou.blog/tags/mysql/"},{"name":"运维","slug":"运维","permalink":"https://bileskou.blog/tags/%E8%BF%90%E7%BB%B4/"}]}